# **1. O-O의 관계 소개**
***
## 인터페이스, 상속, 다형성, 객체지향과 관련된 기타 개념에 대해 간략하게 다룰 것.
***
### **"is-a"**
객체 지향 프로그래밍에는 두 가지 기본 유형의 관계가 있음. "is-a", "has-a"
먼저 __"is-a"__, 상속관계.
객체 지향 시스템은 하나 이상의 뿌리가 있는 상속 계층 구조로 구현됨.
Java는 한 부모에게만 클래스를 상속하는 매우 독특한 상속 환경,
인터페이스를 사용하면 다른 부모에게 있는 것처럼 다르게 보이게 만들 수 있음.

여러 가지 동의어가 존재. 
> 상위 : 기본(base) 클래스, 슈퍼(super) 클래스, 부모(parent) 클래스
> 하위 : 파생(derived) 클래스, 서브(sub) 클래스, 자식(child) 클래스
***
> ex) Station Wagon is-a Car
의 문장에서 Car는 부모 클래스, Station Wagon은 자식 클래스이다.
***
### **"has-a"**
> ex) A Car has-a engine
엔진, 연료탱크, 운전자 등 차의 다양한 구성요소가 있음.
해당 개념은 인스턴스 데이터 즉, has-a를 통해 구현되며, 이는 앞서 배움.
***
# **2. 상속 예시**
***
*상속* : 한 클래스를 부모클래스로 설정하고 다른 클래스를 자식클래스로 설정하는 **재사용의 한 형태**.

자식 클래스는 **부모 클래스의 비공개 멤버가 아닌 모든 멤버를 상속**하기 때문에 상속이라는 용어로 사용함.

Java의 메커니즘 중심 - 자식 클래스는 부모 클래스의 **특수화된, 확장된 버전**.

자식 클래스는 **부모 클래스와 모든 동일한 속성과 메서드를 공유**하므로 이를 계승.

> ex) Station Wagon이라는 자식 클래스에 전체 적재량과, 현재 화물 적재량을 정의하고 그 외의 나머지는 Car 클래스로부터 상속받는다.
> 복사 붙여넣기 대신, 상속을 사용한다.
> 예제를 통해 Car 클래스의 리팩터링 진행 
>> 다른 transport 패키지로 만든 뒤, StationWagon이라는 자식클래스를 만들고 Superclass로서 Car 클래스를 설정. 
>> 슈퍼클래스로부터 생성자를 가져오는 옵션 체크.
>> Car 클래스로부터 메인 메서드를 CarApp 클래스로 분리
>>> 클래스를 만들어놓고 메인 메서드를 분리함으로써 private 속성에 대한 접근가능성 차단

생성자들별 super 키워드를 통해 부모 클래스를 호출할 수 있음
***
# **3. 다형성**
***
*다형성* : Java에서 둘 이상의 클래스가 동일한 메서드 이름을 가질 수 있다는 뜻.

부모는 **최소한 메서드의 이름과 서명을 지정**해야 한다.
서명은 파라미터의 유형과 순서에 따라 서명을 인식하기 때문.
부모의 **모든 자식은 선언을 상속**한다.
메서드를 상속하는 클래스는 원하는 방식으로 필요에 따라 메서드를 구현하거나 *재구현*할 수 있음.
***
> ex) Car 부모 클래스로부터 나온 자식 클래스가 새로운 setSpeed() 메서드를 갖고 있는 경우에 대해 StationWagon.java, CarApp.java 클래스 파일 예제를 만들어가며 학습
> 부모 클래스의 private 속성은 자식 클래스에서 건드릴 수 없음.
> **오버라이드는 런타임에 전혀 영향을 주지 않음.**
>> 하지만 파서와 컴파일러는 부모로부터 받은 내용을 실제로 오버라이드하고 있는지 확인함.
>> 만약 setSpeed의 서명이 int에서 float로 바뀐다면, 오류가 발생.
>> *오버라이드* : 서명이 동일한 것
>> *오버로드* : 이름이 같고 서명이 다른 것
>> @Override를 통해 완전히 동일한 서명을 쓰는지 확인하기 위한 안전 검사
***
CarApp실행에 있어서, 여전히 Car**배열**을 사용함에도 SportsCar 클래스나 StationWagon 클래스가 정상적으로 돌아가는 것을 확인.
**다형성과 상속은 함께 존재**함. 공통된 부모를 가지고 있기 때문에 가능함.
