# **1. 객체만들기**
***
## 생성자를 호출하는 방법과 이런 객체를 JVM에서 저장하고 관리하는 방법에 대해 학습.
***
> ex) Car racerX = new Car();
**racerX는 Car에 대한 참조(reference)**
키워드 new와 인수가 없는 생성자에 대한 참조가 있음.

객체를 만드는 것은 **2step의 프로세스**임.
> **step 1**
> 인스턴스에 대한 참조를 담을 참조를 선언.
> Car racerX;
> 이 문구를 통해 참조표 로의 엔트리가 만들어진다.
> JVM은 이런 것을 의무화하지 않고, 객체 참조를 추적하고 필요한 정보에 연결하는 개념적인 접근 방식.
> **step 2** 
> racerX = new Car();
> Car 클래스가 메모리에 로드되도록 함. 스토리지를 할당함. 스토리지를 할당하고 모두 0으로 초기화한 다음, 생성자를 호출하여 실제로 원하는 방식으로 설정하게 됨. 
> new는 메모리를 할당하는 가상머신과 함께 숨겨진 프로세스를 진행함. 이 프로세스는 초기화된 다음 Car 생성자를 호출하여 새로 할당된 위치에 대한 참조를 제공할 것.

JRE는 JVM과 라이브러리로 구성되어 있음. 
JVM 내에는 JVM의 일부 가상 구현에서 객체를 추적하는데 사용할 수 있는 **참조 테이블이라는 데이터 구조가 있다고 가정**함.
이런 접근에서는, 클래스의 생성자가 호출될 때 클래스가 이미 메모리에 로드되었는지, 클래스 자체가 로드되었는지, 인스턴스가 로드되었는지 확인함. 그렇지 않은 경우, 클래스는 로딩 프로세스를 거치게 됨. 
클래스 로드 프로세스의 일환으로 클래스를 저장할 메모리 블록을 설정하고, 이 블록은 모든 인스턴스에서 공유됨.
***
# **2. 객체 작업**
***
객체가 생성되면 객체의 속성과 메서드를 사용할 수 있으며, 점 표기법을 사용할 수 있음.
> ex) racerX.gasoline = 12;
속성을 **private으로 표시하여 밖에서는 점 표기법이 작동하지 않도록 속성을 제한**할 수 있음.
현재 만든 예제와 같은 경우처럼 main이 같은 클래스 내에 있을 경우, main이 클래스의 일부임으로 클래스의 private 속성에 영향을 미칠 수 있음에 주의.
이 때문에 main을 별도의 테스트 프로그램으로 옮겨 클래스에 포함되지 않고 명시적인 액세스 한정자를 우회하지 않도록 함.
